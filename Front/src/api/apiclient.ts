/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.9.0 (NJsonSchema v9.10.46.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { Globals } from 'app/globals';
import { OAuthService } from 'app/services/o-auth.service';
import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export class BaseClient {
  private oAuthService: OAuthService;

  constructor() {
    this.oAuthService = Globals.injector.get(OAuthService);
  }

  protected transformOptions(options: any) {
    const timestamp = new Date();
    let customHeaders = new HttpHeaders();
    customHeaders = customHeaders.append('Access-Control-Allow-Origin', '*');
    customHeaders = customHeaders.append(
      'Content-Type',
      'application/json; charset=UTF-8'
    );
    if (this.oAuthService.getAuthorizationHeader() !== '') {
      customHeaders = customHeaders.append(
        'Authorization',
        this.oAuthService.getAuthorizationHeader()
      );
    }
    customHeaders = customHeaders.append('Accept', 'application/json');
    customHeaders = customHeaders.append('Cache-Control', 'no-cache');
    customHeaders = customHeaders.append('Pragma', 'no-cache');
    customHeaders = customHeaders.append(
      'X-REL-Timezone-Offset-Mins',
      (timestamp.getTimezoneOffset() * -1).toString()
    );
    customHeaders = customHeaders.append(
      'Access-Control-Allow-Methods',
      'PUT, GET, POST, DELETE, OPTIONS'
    );
    customHeaders = customHeaders.append(
      'Access-Control-Allow-Headers',
      'Origin, X-Requested-With, Content-Type, Accept, Authorization'
    );
    options.headers = customHeaders;
    return Promise.resolve(options);
  }
}

export interface IAuthClient {
    activeUser(userId: string): Observable<ServiceResponseOfBoolean>;
    confirmEmail(userId: string, code: string): Observable<ServiceResponseOfBoolean>;
    deleteUser(userId: string): Observable<ServiceResponseOfBoolean>;
    disableUser(userId: string): Observable<ServiceResponseOfBoolean>;
    forgotPassword(email: string): Observable<ServiceResponse>;
    login(model: LoginModel): Observable<ServiceResponseOfProfileViewModel>;
    register(model: RegisterModel): Observable<ServiceResponseOfProfileViewModel>;
    resetPassword(code: string, confirmPassword: string, password: string, userId: string): Observable<ServiceResponseOfBoolean>;
    getAllUsers(): Observable<ServiceResponseOfListOfApplicationUser>;
    changePassword(oldPassword: string, newPassword: string): Observable<ServiceResponseOfBoolean>;
}

@Injectable()
export class AuthClient extends BaseClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44358";
    }

    activeUser(userId: string): Observable<ServiceResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/activeuser?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processActiveUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveUser(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfBoolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfBoolean>><any>Observable.throw(response_);
        });
    }

    protected processActiveUser(response: HttpResponseBase): Observable<ServiceResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfBoolean.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfBoolean>(<any>null);
    }

    confirmEmail(userId: string, code: string): Observable<ServiceResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/confirmemail?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (code === undefined)
            throw new Error("The parameter 'code' must be defined.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processConfirmEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmail(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfBoolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfBoolean>><any>Observable.throw(response_);
        });
    }

    protected processConfirmEmail(response: HttpResponseBase): Observable<ServiceResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfBoolean.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfBoolean>(<any>null);
    }

    deleteUser(userId: string): Observable<ServiceResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/deleteuser?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfBoolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfBoolean>><any>Observable.throw(response_);
        });
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<ServiceResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfBoolean.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfBoolean>(<any>null);
    }

    disableUser(userId: string): Observable<ServiceResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/disableuser?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDisableUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableUser(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfBoolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfBoolean>><any>Observable.throw(response_);
        });
    }

    protected processDisableUser(response: HttpResponseBase): Observable<ServiceResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfBoolean.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfBoolean>(<any>null);
    }

    forgotPassword(email: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/auth/forgotpassword?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processForgotPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    login(model: LoginModel): Observable<ServiceResponseOfProfileViewModel> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processLogin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(response_);
        });
    }

    protected processLogin(response: HttpResponseBase): Observable<ServiceResponseOfProfileViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfProfileViewModel.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfProfileViewModel>(<any>null);
    }

    register(model: RegisterModel): Observable<ServiceResponseOfProfileViewModel> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(response_);
        });
    }

    protected processRegister(response: HttpResponseBase): Observable<ServiceResponseOfProfileViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfProfileViewModel.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfProfileViewModel>(<any>null);
    }

    resetPassword(code: string, confirmPassword: string, password: string, userId: string): Observable<ServiceResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/resetpassword?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (confirmPassword !== undefined)
            url_ += "confirmPassword=" + encodeURIComponent("" + confirmPassword) + "&"; 
        if (password === undefined)
            throw new Error("The parameter 'password' must be defined.");
        else
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processResetPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfBoolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfBoolean>><any>Observable.throw(response_);
        });
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ServiceResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfBoolean.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfBoolean>(<any>null);
    }

    getAllUsers(): Observable<ServiceResponseOfListOfApplicationUser> {
        let url_ = this.baseUrl + "/api/auth/getallusers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };
        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            debugger;
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAllUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfApplicationUser>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfApplicationUser>><any>Observable.throw(response_);
        });
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<ServiceResponseOfListOfApplicationUser> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfApplicationUser.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfApplicationUser>(<any>null);
    }

    changePassword(oldPassword: string, newPassword: string): Observable<ServiceResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/changepassword?";
        if (oldPassword === undefined)
            throw new Error("The parameter 'oldPassword' must be defined.");
        else
            url_ += "oldPassword=" + encodeURIComponent("" + oldPassword) + "&"; 
        if (newPassword === undefined)
            throw new Error("The parameter 'newPassword' must be defined.");
        else
            url_ += "newPassword=" + encodeURIComponent("" + newPassword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processChangePassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfBoolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfBoolean>><any>Observable.throw(response_);
        });
    }

    protected processChangePassword(response: HttpResponseBase): Observable<ServiceResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfBoolean.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfBoolean>(<any>null);
    }
}

export class ServiceResponse implements IServiceResponse {
    errorMessages?: ValidationFailure[];
    successful: boolean;
    token?: string;

    constructor(data?: IServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["errorMessages"] && data["errorMessages"].constructor === Array) {
                this.errorMessages = [];
                for (let item of data["errorMessages"])
                    this.errorMessages.push(ValidationFailure.fromJS(item));
            }
            this.successful = data["successful"];
            this.token = data["token"];
        }
    }

    static fromJS(data: any): ServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errorMessages && this.errorMessages.constructor === Array) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item.toJSON());
        }
        data["successful"] = this.successful;
        data["token"] = this.token;
        return data; 
    }
}

export interface IServiceResponse {
    errorMessages?: ValidationFailure[];
    successful: boolean;
    token?: string;
}

export class ServiceResponseOfBoolean extends ServiceResponse implements IServiceResponseOfBoolean {
    data: boolean;

    constructor(data?: IServiceResponseOfBoolean) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"];
        }
    }

    static fromJS(data: any): ServiceResponseOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfBoolean extends IServiceResponse {
    data: boolean;
}

/** Defines a validation failure */
export class ValidationFailure implements IValidationFailure {
    /** The name of the property. */
    propertyName?: string;
    /** The error message */
    errorMessage?: string;
    /** The property value that caused the failure. */
    attemptedValue?: any;
    /** Custom state associated with the failure. */
    customState?: any;
    /** Custom severity level associated with the failure. */
    severity: Severity;
    /** Gets or sets the error code. */
    errorCode?: string;
    /** Gets or sets the formatted message arguments.
These are values for custom formatted message in validator resource files
Same formatted message can be reused in UI and with same number of format placeholders
Like "Value {0} that you entered should be {1}" */
    formattedMessageArguments?: any[];
    /** Gets or sets the formatted message placeholder values. */
    formattedMessagePlaceholderValues?: { [key: string] : any; };
    /** The resource name used for building the message */
    resourceName?: string;

    constructor(data?: IValidationFailure) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.propertyName = data["propertyName"];
            this.errorMessage = data["errorMessage"];
            this.attemptedValue = data["attemptedValue"];
            this.customState = data["customState"];
            this.severity = data["severity"];
            this.errorCode = data["errorCode"];
            if (data["formattedMessageArguments"] && data["formattedMessageArguments"].constructor === Array) {
                this.formattedMessageArguments = [];
                for (let item of data["formattedMessageArguments"])
                    this.formattedMessageArguments.push(item);
            }
            if (data["formattedMessagePlaceholderValues"]) {
                this.formattedMessagePlaceholderValues = {};
                for (let key in data["formattedMessagePlaceholderValues"]) {
                    if (data["formattedMessagePlaceholderValues"].hasOwnProperty(key))
                        this.formattedMessagePlaceholderValues[key] = data["formattedMessagePlaceholderValues"][key];
                }
            }
            this.resourceName = data["resourceName"];
        }
    }

    static fromJS(data: any): ValidationFailure {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationFailure();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        data["attemptedValue"] = this.attemptedValue;
        data["customState"] = this.customState;
        data["severity"] = this.severity;
        data["errorCode"] = this.errorCode;
        if (this.formattedMessageArguments && this.formattedMessageArguments.constructor === Array) {
            data["formattedMessageArguments"] = [];
            for (let item of this.formattedMessageArguments)
                data["formattedMessageArguments"].push(item);
        }
        if (this.formattedMessagePlaceholderValues) {
            data["formattedMessagePlaceholderValues"] = {};
            for (let key in this.formattedMessagePlaceholderValues) {
                if (this.formattedMessagePlaceholderValues.hasOwnProperty(key))
                    data["formattedMessagePlaceholderValues"][key] = this.formattedMessagePlaceholderValues[key];
            }
        }
        data["resourceName"] = this.resourceName;
        return data; 
    }
}

/** Defines a validation failure */
export interface IValidationFailure {
    /** The name of the property. */
    propertyName?: string;
    /** The error message */
    errorMessage?: string;
    /** The property value that caused the failure. */
    attemptedValue?: any;
    /** Custom state associated with the failure. */
    customState?: any;
    /** Custom severity level associated with the failure. */
    severity: Severity;
    /** Gets or sets the error code. */
    errorCode?: string;
    /** Gets or sets the formatted message arguments.
These are values for custom formatted message in validator resource files
Same formatted message can be reused in UI and with same number of format placeholders
Like "Value {0} that you entered should be {1}" */
    formattedMessageArguments?: any[];
    /** Gets or sets the formatted message placeholder values. */
    formattedMessagePlaceholderValues?: { [key: string] : any; };
    /** The resource name used for building the message */
    resourceName?: string;
}

/** Specifies the severity of a rule. */
export enum Severity {
    Error = 0, 
    Warning = 1, 
    Info = 2, 
}

export class LoginModel implements ILoginModel {
    email: string;
    password: string;
    rememberMe: boolean;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.password = data["password"];
            this.rememberMe = data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data; 
    }
}

export interface ILoginModel {
    email: string;
    password: string;
    rememberMe: boolean;
}

export class ServiceResponseOfProfileViewModel extends ServiceResponse implements IServiceResponseOfProfileViewModel {
    data?: ProfileViewModel;

    constructor(data?: IServiceResponseOfProfileViewModel) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? ProfileViewModel.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfProfileViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfProfileViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfProfileViewModel extends IServiceResponse {
    data?: ProfileViewModel;
}

export class ProfileViewModel implements IProfileViewModel {
    email?: string;
    firstName?: string;
    id?: string;
    lastName?: string;
    token?: string;

    constructor(data?: IProfileViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.firstName = data["firstName"];
            this.id = data["id"];
            this.lastName = data["lastName"];
            this.token = data["token"];
        }
    }

    static fromJS(data: any): ProfileViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["id"] = this.id;
        data["lastName"] = this.lastName;
        data["token"] = this.token;
        return data; 
    }
}

export interface IProfileViewModel {
    email?: string;
    firstName?: string;
    id?: string;
    lastName?: string;
    token?: string;
}

export class RegisterModel implements IRegisterModel {
    confirmPassword?: string;
    email: string;
    firstName: string;
    lastName: string;
    password: string;
    userName: string;

    constructor(data?: IRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.confirmPassword = data["confirmPassword"];
            this.email = data["email"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.password = data["password"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): RegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["confirmPassword"] = this.confirmPassword;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["password"] = this.password;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IRegisterModel {
    confirmPassword?: string;
    email: string;
    firstName: string;
    lastName: string;
    password: string;
    userName: string;
}

export class ServiceResponseOfListOfApplicationUser extends ServiceResponse implements IServiceResponseOfListOfApplicationUser {
    data?: ApplicationUser[];

    constructor(data?: IServiceResponseOfListOfApplicationUser) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(ApplicationUser.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfApplicationUser extends IServiceResponse {
    data?: ApplicationUser[];
}

export class IdentityUserOfString implements IIdentityUserOfString {
    id?: string;
    userName?: string;
    normalizedUserName?: string;
    email?: string;
    normalizedEmail?: string;
    emailConfirmed: boolean;
    passwordHash?: string;
    securityStamp?: string;
    concurrencyStamp?: string;
    phoneNumber?: string;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd?: Date;
    lockoutEnabled: boolean;
    accessFailedCount: number;

    constructor(data?: IIdentityUserOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.normalizedUserName = data["normalizedUserName"];
            this.email = data["email"];
            this.normalizedEmail = data["normalizedEmail"];
            this.emailConfirmed = data["emailConfirmed"];
            this.passwordHash = data["passwordHash"];
            this.securityStamp = data["securityStamp"];
            this.concurrencyStamp = data["concurrencyStamp"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneNumberConfirmed = data["phoneNumberConfirmed"];
            this.twoFactorEnabled = data["twoFactorEnabled"];
            this.lockoutEnd = data["lockoutEnd"] ? new Date(data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = data["lockoutEnabled"];
            this.accessFailedCount = data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUserOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data; 
    }
}

export interface IIdentityUserOfString {
    id?: string;
    userName?: string;
    normalizedUserName?: string;
    email?: string;
    normalizedEmail?: string;
    emailConfirmed: boolean;
    passwordHash?: string;
    securityStamp?: string;
    concurrencyStamp?: string;
    phoneNumber?: string;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd?: Date;
    lockoutEnabled: boolean;
    accessFailedCount: number;
}

/** The default implementation of IdentityUser`1 which uses a string as a primary key. */
export class IdentityUser extends IdentityUserOfString implements IIdentityUser {

    constructor(data?: IIdentityUser) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): IdentityUser {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

/** The default implementation of IdentityUser`1 which uses a string as a primary key. */
export interface IIdentityUser extends IIdentityUserOfString {
}

export class ApplicationUser extends IdentityUser implements IApplicationUser {
    accountId?: string;
    disabled: boolean;
    firstName?: string;
    lastName?: string;

    constructor(data?: IApplicationUser) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.accountId = data["accountId"];
            this.disabled = data["disabled"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["disabled"] = this.disabled;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        super.toJSON(data);
        return data; 
    }
}

export interface IApplicationUser extends IIdentityUser {
    accountId?: string;
    disabled: boolean;
    firstName?: string;
    lastName?: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}